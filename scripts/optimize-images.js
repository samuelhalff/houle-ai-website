/*
  Batch-compress images in public/assets in-place using sharp.
  - Resizes down to a max width to avoid unnecessarily large sources
  - Re-encodes JPEG/PNG/WebP with reasonable quality
  - Replaces original only if the optimized file is smaller
*/

const fs = require("fs");
const path = require("path");
const sharp = require("sharp");

const ASSETS_DIR = path.resolve(process.cwd(), "public/assets");
const CODE_DIRS = [
  path.resolve(process.cwd(), "app"),
  path.resolve(process.cwd(), "src"),
];
const ALLOWED_EXT = new Set([".jpg", ".jpeg", ".png", ".webp", ".avif"]);
const EXCLUDE_DIRS = new Set(["downloads"]); // keep PDFs etc.

// Default cap: heroes use ~520-600px; cards ~800px. Use 800px as a safe upper-bound.
const MAX_WIDTH = Number(process.env.MAX_IMG_WIDTH || 800);
// Allow larger hero images (new hero bird illustrations) for crispness on high-DPR displays
const HERO_MAX_WIDTH = Number(process.env.HERO_MAX_IMG_WIDTH || 1600);
const CARD_MAX_WIDTH = Number(process.env.CARD_MAX_IMG_WIDTH || 800);

// Map known assets to a specific cap (override default)
const WIDTH_OVERRIDES = new Map([
  ["/assets/main-bg.jpg", 640],
  ["/assets/services/odoo-services.png", 640],
  ["/assets/services/accounting-services.png", 640],
  ["/assets/services/corporate-services.png", 640],
  ["/assets/services/outsourcing.png", 640],
  ["/assets/services/tax-desk.png", 640],
  ["/assets/services/hr-services.png", 640],
  ["/assets/services/domiciliation.png", 640],
  ["/assets/abstract-background-light.webp", 1920],
  ["/assets/abstract-background-light.avif", 1920],
  ["/assets/abstract-background-dark.webp", 1920],
  ["/assets/abstract-background-dark.avif", 1920],
  // Limit especially heavy service hero to reduce transform time and bytes
  ["/assets/hero/services/incorporation-hero.jpg", 1400],
  ["/assets/hero/services/incorporation-hero.webp", 1400],
  ["/assets/hero/services/incorporation-hero.avif", 1400],
]);

// Optionally load caps from a CSV generated by scripts/audit-image-usage.js
const USAGE_CSV = process.env.IMG_USAGE_CSV || path.resolve(process.cwd(), "image-usage.csv");
const SCALE = Number(process.env.IMG_CAP_SCALE || 1.5); // bump for DPR safety
const usageCaps = new Map();

function loadUsageCaps() {
  if (!fs.existsSync(USAGE_CSV)) return;
  try {
    const text = fs.readFileSync(USAGE_CSV, "utf8");
    const lines = text.split(/\r?\n/).filter(Boolean);
    for (const line of lines) {
      if (line.startsWith("asset,")) continue;
      const [asset, capStr] = line.split(",");
      const cap = Number(capStr || 0);
      if (!asset || !asset.startsWith("/")) continue;
      if (cap > 0) usageCaps.set(asset, Math.round(cap * SCALE));
    }
    console.log(`Loaded ${usageCaps.size} caps from ${USAGE_CSV} (scale=${SCALE})`);
  } catch (e) {
    console.warn("Failed to read usage CSV:", e.message);
  }
}
loadUsageCaps();

async function optimizeFile(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  if (!ALLOWED_EXT.has(ext)) return { skipped: true };

  const stat = await fs.promises.stat(filePath);
  const inputSize = stat.size;

  // Read metadata to decide resize
  const img = sharp(filePath, { failOn: "none" });
  const meta = await img.metadata();
  const width = meta.width || 0;

  let pipeline = img.clone();
  const relFromPublic = filePath.split("public")[1] || ""; // e.g., /assets/...
  const override = usageCaps.get(relFromPublic) || WIDTH_OVERRIDES.get(relFromPublic);
  // Heuristic: hero-like images (main-bg, hero) can use a higher cap
  const isHero = /main-bg|hero/i.test(relFromPublic);
  const cap = isHero ? HERO_MAX_WIDTH : CARD_MAX_WIDTH;
  const targetWidth = override || (width && width > cap ? cap : width);
  if (targetWidth && width && width > targetWidth) {
    pipeline = pipeline.resize({ width: targetWidth });
  }

  // 1) Always produce AVIF and WebP variants for jpg/png/webp/avif
  const isServiceHeroPath = /\/assets\/hero\/services\//.test(relFromPublic);
  // Only emit a .webp variant when the source is not already a .webp to avoid same input/output
  const isWebpSource = ext === ".webp";
  let webpTarget = null;
  if (!isWebpSource) {
    webpTarget = filePath.replace(ext, ".webp");
    // Increase quality for hero/service images to avoid blurriness
    const webpQuality = isServiceHeroPath ? 82 : 72;
    const webpPipeline = pipeline.clone().webp({ quality: webpQuality, effort: 5 });
    await webpPipeline.toFile(webpTarget);
  }
  const avifTarget = filePath.replace(ext, ".avif");
  const avifQuality = isServiceHeroPath ? 70 : 60;
  const avifPipeline = pipeline.clone().avif({ quality: avifQuality, effort: 5 });
  await avifPipeline.toFile(avifTarget);

  // 2) Also keep optimized original format in-place (only replace if meaningfully smaller)
  //    For tiny files (<40kB), skip original recompress to avoid churn but still produce .webp.
  if (inputSize < 40 * 1024) {
    return { optimized: false, before: inputSize, after: inputSize, webp: webpTarget, avif: avifTarget };
  }
  let originalEncodedPath = null;
  if (ext === ".jpg" || ext === ".jpeg") {
    originalEncodedPath = filePath + ".tmp";
    await pipeline
      .clone()
      .jpeg({ quality: 75, mozjpeg: true, progressive: true, chromaSubsampling: "4:2:0" })
      .toFile(originalEncodedPath);
  } else if (ext === ".png") {
    originalEncodedPath = filePath + ".tmp";
    await pipeline
      .clone()
      .png({ quality: 80, compressionLevel: 9, palette: true })
      .toFile(originalEncodedPath);
  } else if (ext === ".webp") {
    originalEncodedPath = filePath + ".tmp";
    await pipeline
      .clone()
      .webp({ quality: 75, effort: 5 })
      .toFile(originalEncodedPath);
  }

  if (originalEncodedPath) {
    const outStat = await fs.promises.stat(originalEncodedPath);
    const outputSize = outStat.size;
    const smaller = outputSize + outputSize * 0.01 < inputSize;
    if (smaller) {
      await fs.promises.rename(originalEncodedPath, filePath);
    return { optimized: true, before: inputSize, after: outputSize, webp: webpTarget, avif: avifTarget };
    } else {
      await fs.promises.unlink(originalEncodedPath).catch(() => {});
    return { optimized: false, before: inputSize, after: inputSize, webp: webpTarget, avif: avifTarget };
    }
  }

  return { optimized: false, before: inputSize, after: inputSize, webp: webpTarget, avif: avifTarget };
}

async function walk(dir) {
  const entries = await fs.promises.readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.name.startsWith(".")) continue;
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      if (EXCLUDE_DIRS.has(entry.name)) continue;
      await walk(full);
    } else {
      try {
        const res = await optimizeFile(full);
        if (res && res.webp) {
          // Queue reference replacement from original to .webp
          queueReplacement(full, res.webp);
        }
        if (res && res.optimized) {
          const saved = ((res.before - res.after) / res.before * 100).toFixed(1);
          console.log(`optimized: ${path.relative(ASSETS_DIR, full)}  -${saved}% (${(res.before/1024).toFixed(0)}kB → ${(res.after/1024).toFixed(0)}kB)`);
        }
      } catch (e) {
        console.warn("skip:", path.relative(ASSETS_DIR, full), e.message);
      }
    }
  }
}

(async () => {
  console.log("Optimizing images in:", ASSETS_DIR);
  const before = await dirSize(ASSETS_DIR);
  await walk(ASSETS_DIR);
  // Apply code reference replacements
  await applyReplacements();
  const after = await dirSize(ASSETS_DIR);
  const savedBytes = before - after;
  const savedPct = before ? ((savedBytes / before) * 100).toFixed(1) : 0;
  console.log(`Done. Size: ${(before/1024/1024).toFixed(2)}MB → ${(after/1024/1024).toFixed(2)}MB (-${savedPct}%)`);
})().catch((e) => {
  console.error(e);
  process.exit(1);
});

async function dirSize(dir) {
  let total = 0;
  const entries = await fs.promises.readdir(dir, { withFileTypes: true });
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) total += await dirSize(full);
    else total += (await fs.promises.stat(full)).size;
  }
  return total;
}

// --- Reference replacement ---
const replacements = new Map(); // key: original (as used in code), value: preferred asset

function queueReplacement(originalFsPath, webpFsPath) {
  // Determine the smallest viable asset among original, .webp, and .avif
  const tryStat = (p) => {
    try { return fs.statSync(p).size; } catch { return Infinity; }
  };
  const avifFsPath = originalFsPath.replace(/\.(jpe?g|png|webp|avif)$/i, ".avif");
  const origSize = tryStat(originalFsPath);
  const webpSize = tryStat(webpFsPath);
  const avifSize = tryStat(avifFsPath);

  // Choose the best path by bytes; prefer AVIF over WebP when sizes are equal
  let bestFsPath = originalFsPath;
  let bestSize = origSize;
  if (avifSize <= bestSize) { bestFsPath = avifFsPath; bestSize = avifSize; }
  if (webpSize < bestSize)  { bestFsPath = webpFsPath; bestSize = webpSize; }

  // Only replace references if the best is meaningfully smaller (>1% and >5KB)
  const pct = origSize && Number.isFinite(bestSize) ? (origSize - bestSize) / origSize : 0;
  const diff = origSize - bestSize;
  if (!Number.isFinite(bestSize) || pct < 0.01 || diff < 5 * 1024) return;

  // Convert to web root path strings used in code, e.g., /assets/...
  const toWebPath = (p) => {
    const i = p.lastIndexOf("public");
    return i >= 0 ? p.slice(i + "public".length).replace(/\\/g, "/") : null;
  };
  const origWeb = toWebPath(originalFsPath);
  const bestWeb = toWebPath(bestFsPath);
  if (!origWeb || !bestWeb) return;

  const ext = path.extname(origWeb).toLowerCase();
  if (ext === ".jpg" || ext === ".jpeg" || ext === ".png" || ext === ".webp") {
    replacements.set(origWeb, bestWeb);
  }
}

async function applyReplacements() {
  if (replacements.size === 0) return;
  console.log("Updating code references to .webp where applicable...");
  const codeFiles = await collectCodeFiles(CODE_DIRS);
  for (const file of codeFiles) {
    const content = await fs.promises.readFile(file, "utf8");
    let newContent = content;
    let changed = false;
    for (const [from, to] of replacements.entries()) {
      if (newContent.includes(from)) {
        newContent = newContent.split(from).join(to);
        changed = true;
      }
    }
    if (changed) {
      await fs.promises.writeFile(file, newContent);
      console.log("updated refs:", path.relative(process.cwd(), file));
    }
  }
  console.log("Reference updates complete. Originals are kept for safety; you can delete unused originals after validation.");
}

async function collectCodeFiles(dirs) {
  const out = [];
  for (const dir of dirs) {
    const entries = await fs.promises.readdir(dir, { withFileTypes: true });
    for (const e of entries) {
      if (e.name.startsWith(".")) continue;
      const full = path.join(dir, e.name);
      if (e.isDirectory()) {
        out.push(...(await collectCodeFiles([full])));
      } else if (/\.(tsx?|jsx?)$/.test(e.name)) {
        out.push(full);
      }
    }
  }
  return out;
}
